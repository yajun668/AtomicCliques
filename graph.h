#ifndef graph_h
#define graph_h
#endif /* graph_h */
#include <stdio.h>
#include <iostream>
#include<fstream>
#include <sstream>
#include <vector>
#include<set>
#include<map>
#include <cstring>
#include <algorithm>
#include <queue>
#include <unistd.h> //used for changing directory
#include <stack>
#include <limits.h>
#include <chrono>
//#include "omp.h" //uncomment when running on cowboy cluster in order to use OpenMP for parallel computing

using namespace std;
typedef chrono::high_resolution_clock::time_point chrono_time_point;
typedef chrono::high_resolution_clock chrono_clock;

typedef vector<string> StrV;
typedef set<string> StrS;
typedef set<long> LongSet;
typedef map<long, LongSet> Adj;

struct VSet
{
    vector<long> V; // store V^0: universal vertex set. Note that these stored vertex indices may NOT be consecutive.
    map<long, long> v2idx; // convert V^0 index from 0 to |V|-1
    map<pair<long ,long>, LongSet> edgeGraphSet; // Set of graphs containing edge uv; eg, edgeGraphSet[1,2] = 1,3,8 means that graphs 1, 3, 8 contain edge 1-2
    map<long, LongSet> vertexGraphSet; //set of graphs containing vertex v; eg: vertexGraphSet[2] = 2,3 means that graphs 2 and 3 contain vertex 2
};

// Classes
class Graph
{	//	Caution: may crash if graph size above 2,147,483,647;
private:

public:
    Adj adj; //Adjacency List
    string graphname;
    long num_verts; //number of vertices
    long num_edges; //number of edges

    //functions
    Graph();
    Graph(long n);
    ~Graph();
    bool IsContainV(long a);
    void AddE(const long & a, const long & b, bool recount_v_e = false); //add edge a-b
    void CountVE(); // count vertex and edge
    bool IsAdj(const long & a, const long & b); //check if a and b are adjacent
    vector<long> kBFS(long s, long k); //first argument is the starting vertex s; 2nd argument is to do BFS up to level-k
    vector<vector<long>> getComponent(); //Identify connected components
    //Graph CreateInducedGraph(const vector<long> &S); //create a subgraph induced by S
};

// functions related to graph
typedef vector<Graph*> GSeq;
void LoadGSeq(GSeq & gs_val, VSet & v0_val, const string & file_val); // read graph collections
Graph EdgePeeling(VSet & v0_val, const long num_graphs); // edge peeling
void WriteGraph2AdjList(string file_name, vector<long> & auxVset); //write the auxiliary graph generated by edge peeling into a txt file with adjacent list format: graph index is 1, 2, .., n
void WriteGraph2EdgeList(string file_name, vector<long> & auxVset); //write the auxiliary graph generated by edge peeling into a txt file with edge list format: graph index is 1, 2, .., n
void WriteGraphBatch(string graph_list);
void ClearGSeq(GSeq & gs_val); //clear graph collections
void KCore(GSeq & gs,VSet & v0, long k);

